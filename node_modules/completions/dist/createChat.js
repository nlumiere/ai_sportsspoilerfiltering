"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createChat = void 0;
const createCompletions_1 = require("./createCompletions");
const retry_1 = require("./retry");
const omit_1 = require("./omit");
const createUserFunction_1 = require("./createUserFunction");
const ajv_1 = __importDefault(require("ajv"));
const extendPrompt = (prompt, expect) => {
    return `${prompt}

Respond ONLY with a JSON object that satisfies the following schema:

${JSON.stringify(expect.schema, null, 2)}

Examples:

${expect.examples
        .map((example) => JSON.stringify(example, null, 2))
        .join("\n\n")}`;
};
/**
 * @property apiKey - OpenAI API key.
 * @property frequencyPenalty - Number between -2.0 and 2.0. Positive values penalize new
 *    tokens based on their existing frequency in the text so far, decreasing the model's
 *    likelihood to repeat the same line verbatim.
 * @property logitBias - Number between -2.0 and 2.0. Positive values penalize new tokens
 *    based on their existing frequency in the text so far, decreasing the model's likelihood to
 *    repeat the same line verbatim.
 * @property maxTokens â€“Â The maximum number of tokens to generate in the chat completion.
 *    The total length of input tokens and generated tokens is limited by the model's context length.
 * @property model - ID of the model to use. See the model endpoint compatibility table for
 *    details on which models work with the Chat API.
 * @property functionCall - Controls how the model responds to function calls.
 *    "none" means the model does not call a function, and responds to the end-user.
 *    "auto" means the model can pick between an end-user or calling a function.
 *    Specifying a particular function via {"name":\ "my_function"} forces the model to call that function.
 *    "none" is the default when no functions are present.
 *    "auto" is the default if functions are present.
 * @property functions - A list of functions the model may generate JSON inputs for.
 * @property n - How many chat completion choices to generate for each input message.
 * @property presencePenalty - Number between -2.0 and 2.0. Positive values penalize new
 *    tokens based on whether they appear in the text so far, increasing the model's
 *    likelihood to talk about new topics.
 * @property stop - Up to 4 sequences where the API will stop generating further tokens.
 * @property temperature - What sampling temperature to use, between 0 and 2. Higher values
 *    like 0.8 will make the output more random, while lower values like 0.2 will make it
 *    more focused and deterministic.
 *    We generally recommend altering this or top_p but not both.
 * @property topP - An alternative to sampling with temperature, called nucleus sampling,
 *    where the model considers the results of the tokens with top_p probability mass.
 *    So 0.1 means only the tokens comprising the top 10% probability mass are considered.
 *    We generally recommend altering this or temperature but not both.
 * @property user - A unique identifier representing your end-user, which can help OpenAI
 *    to monitor and detect abuse.
 */
const createChat = (options) => {
    const messages = [];
    const userFunctions = {};
    for (const functionOptions of options.functions || []) {
        userFunctions[functionOptions.name] = (0, createUserFunction_1.createUserFunction)(functionOptions);
    }
    const complete = async (messageOptions) => {
        const response = await (0, retry_1.retry)(() => {
            return (0, createCompletions_1.createCompletions)({
                messages,
                onUpdate: messageOptions?.onUpdate,
                ...options,
                ...(messageOptions ? (0, omit_1.omit)(messageOptions, "expect") : {}),
            });
        });
        if (!response) {
            throw new Error("No result");
        }
        const { choices } = response;
        if (choices.length === 0) {
            throw new Error("No choices returned");
        }
        if (choices.length > 1) {
            throw new Error("Expected only one choice");
        }
        const choice = choices[0];
        return choice;
    };
    const parseResponse = (choice, expect) => {
        const parsed = JSON.parse(choice.content);
        const ajv = new ajv_1.default();
        const validate = ajv.compile(expect.schema);
        const valid = validate(parsed);
        if (!valid) {
            throw new Error(`Invalid response: ${JSON.stringify(validate.errors)}`);
        }
        return {
            ...choice,
            content: parsed,
        };
    };
    async function sendMessage(prompt, messageOptions) {
        const message = {
            content: messageOptions?.expect
                ? extendPrompt(prompt, messageOptions.expect)
                : prompt,
            role: "user",
        };
        messages.push(message);
        let choice = await complete(messageOptions);
        messages.push((0, omit_1.omit)(choice, "finishReason"));
        if (choice.function_call) {
            const functionName = choice.function_call.name;
            const userFunction = userFunctions[functionName];
            if (!userFunction) {
                throw new Error(`Function "${functionName}" not found in user functions`);
            }
            const functionArgs = userFunction.parseArguments(choice.function_call.arguments);
            const result = await userFunction.function(functionArgs);
            messages.push({
                content: JSON.stringify(result),
                role: "function",
                name: choice.function_call.name,
            });
            choice = await complete(messageOptions);
            choice.functionCall = {
                name: functionName,
                arguments: functionArgs,
            };
        }
        // TypeScript can't properly narrow the type in the function body.
        // This is why we have to use `as any` here.
        if (messageOptions?.expect) {
            return parseResponse(choice, messageOptions.expect);
        }
        else {
            return choice;
        }
    }
    const addMessage = (message) => {
        messages.push(message);
    };
    return {
        addMessage,
        getMessages: () => messages,
        sendMessage,
    };
};
exports.createChat = createChat;
