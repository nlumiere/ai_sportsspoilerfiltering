"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCompletions = void 0;
const zod_1 = require("zod");
const errors_1 = require("./errors");
const createUserFunction_1 = require("./createUserFunction");
const RoleZodSchema = zod_1.z.enum(["system", "user", "assistant", "function"]);
const MessageZodSchema = zod_1.z
    .object({
    content: zod_1.z.string(),
    role: RoleZodSchema,
    name: zod_1.z.string().optional(),
    function_call: zod_1.z
        .object({
        name: zod_1.z.string(),
        arguments: zod_1.z.string(),
    })
        .optional(),
})
    .strict();
const ResponseChunkZodSchema = zod_1.z
    .object({
    id: zod_1.z.string(),
    object: zod_1.z.literal("chat.completion.chunk"),
    created: zod_1.z.number(),
    model: zod_1.z.string(),
    choices: zod_1.z.array(zod_1.z.object({
        index: zod_1.z.number(),
        finish_reason: zod_1.z.string().nullable(),
        delta: zod_1.z.union([
            zod_1.z.object({
                content: zod_1.z.null().optional(),
                role: RoleZodSchema.optional(),
                function_call: zod_1.z.object({
                    name: zod_1.z.string().optional(),
                    arguments: zod_1.z.string(),
                }),
            }),
            zod_1.z.object({
                content: zod_1.z.string(),
            }),
            zod_1.z.object({
                role: RoleZodSchema,
            }),
            zod_1.z.object({}),
        ]),
    })),
})
    .strict();
const CompletionsOptionsZodSchema = zod_1.z
    .object({
    apiUrl: zod_1.z.string().optional(),
    onUpdate: zod_1.z
        .function()
        .args(zod_1.z.object({
        cancel: zod_1.z.function().returns(zod_1.z.void()),
        message: ResponseChunkZodSchema,
    }))
        .returns(zod_1.z.void())
        .optional(),
    apiKey: zod_1.z.string(),
    model: zod_1.z.string(),
    messages: zod_1.z.array(MessageZodSchema),
    temperature: zod_1.z.number().optional(),
    topP: zod_1.z.number().optional(),
    n: zod_1.z.number().optional(),
    stop: zod_1.z.union([zod_1.z.string(), zod_1.z.array(zod_1.z.string())]).optional(),
    frequencyPenalty: zod_1.z.number().optional(),
    presencePenalty: zod_1.z.number().optional(),
    logitBias: zod_1.z.record(zod_1.z.number()).optional(),
    maxTokens: zod_1.z.number().optional(),
    user: zod_1.z.string().optional(),
    functionCall: zod_1.z
        .union([zod_1.z.enum(["auto", "none"]), zod_1.z.object({ name: zod_1.z.string() })])
        .optional(),
    functions: zod_1.z.array(createUserFunction_1.FunctionZodSchema).optional(),
})
    .strict();
const ChoiceZodSchema = zod_1.z
    .object({
    role: RoleZodSchema,
    content: zod_1.z.string(),
    finishReason: zod_1.z.string(),
    function_call: zod_1.z
        .object({
        name: zod_1.z.string(),
        arguments: zod_1.z.string(),
    })
        .optional(),
})
    .strict();
const consumeStream = async (stream, onUpdate) => {
    const reader = stream.pipeThrough(new TextDecoderStream()).getReader();
    const choices = [];
    let cancelled = false;
    while (true) {
        const { value, done } = await reader.read();
        if (done) {
            break;
        }
        // {
        //   "error": {
        //     "message": "This model's maximum context length is 4097 tokens. However, your messages resulted in 5034 tokens. Please reduce the length of the messages.",
        //     "type": "invalid_request_error",
        //     "param": "messages",
        //     "code": "context_length_exceeded"
        //   }
        // }
        if (value.startsWith("{")) {
            await reader.cancel();
            // As far as I can tell, if the response is an object, then it is an unrecoverable error.
            throw new errors_1.UnrecoverableRemoteError(value);
        }
        for (const chunk of value
            .split("\n")
            .map((chunk) => chunk.trim())
            .filter(Boolean)) {
            if (done) {
                break;
            }
            if (chunk === "") {
                continue;
            }
            if (chunk === "data: [DONE]") {
                await reader.cancel();
                break;
            }
            if (!chunk.startsWith("data: ")) {
                throw new Error(`Unexpected message: ${chunk}`);
            }
            let responseChunk;
            try {
                responseChunk = ResponseChunkZodSchema.parse(JSON.parse(chunk.slice("data: ".length)));
            }
            catch (error) {
                console.log('could not parse chunk:\n\n"""\n', chunk, '\n"""\n');
                console.log('read value:\n\n"""\n', value, '\n"""\n');
                console.error(error);
                await reader.cancel();
                throw error;
            }
            onUpdate({
                cancel: () => {
                    cancelled = true;
                    reader.cancel();
                },
                message: responseChunk,
            });
            for (const choiceChunk of responseChunk.choices) {
                const index = choiceChunk.index;
                const choice = (choices[index] = choices[index] ?? {});
                if ("finish_reason" in choiceChunk &&
                    choiceChunk.finish_reason !== null) {
                    choice.finishReason = choiceChunk.finish_reason;
                }
                if ("role" in choiceChunk.delta) {
                    choice.role = choiceChunk.delta.role;
                }
                if ("content" in choiceChunk.delta) {
                    choice.content = choice.content ?? "";
                    choice.content += choiceChunk.delta.content;
                }
                if ("function_call" in choiceChunk.delta) {
                    choice.function_call = choice.function_call ?? {
                        name: "",
                        arguments: "",
                    };
                    choice.function_call.name +=
                        choiceChunk.delta.function_call.name ?? "";
                    choice.function_call.arguments +=
                        choiceChunk.delta.function_call.arguments ?? "";
                }
            }
        }
    }
    if (cancelled) {
        throw new errors_1.CancelledCompletionError(choices);
    }
    return choices;
};
const parseResponse = (response) => {
    return response.choices.map((choice) => {
        const parsedChoice = {
            role: choice.message.role,
            // I've seen content to be null in case of a function call
            content: choice.message.content ?? "",
            finishReason: choice.finish_reason,
        };
        if (choice.message.function_call) {
            parsedChoice.function_call = {
                name: choice.message.function_call.name,
                arguments: choice.message.function_call.arguments,
            };
        }
        return parsedChoice;
    });
};
const createCompletions = async (options) => {
    CompletionsOptionsZodSchema.parse(options);
    const response = await fetch(options.apiUrl ?? "https://api.openai.com/v1/chat/completions", {
        headers: {
            Authorization: `Bearer ${options.apiKey}`,
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            messages: options.messages,
            model: options.model,
            stream: Boolean(options.onUpdate),
            temperature: options.temperature,
            top_p: options.topP,
            n: options.n,
            stop: options.stop,
            frequency_penalty: options.frequencyPenalty,
            presence_penalty: options.presencePenalty,
            logit_bias: options.logitBias,
            max_tokens: options.maxTokens,
            user: options.user,
            function_call: options.functionCall,
            functions: options.functions,
        }),
        method: "POST",
    });
    if (!response.body) {
        throw new Error("Expected response to have a body");
    }
    const choices = options.onUpdate
        ? await consumeStream(response.body, options.onUpdate)
        : parseResponse(await response.json());
    // When replying to after a function return, the role is not set, so we need to set it ourselves.
    // I suspect that this is an oversight by the api since it requires the role be set in
    // the subsequent calls to the endpoint for the response message from the function.
    for (const choice of choices) {
        if (choice.role === undefined) {
            choice.role = "assistant";
        }
    }
    return {
        choices: ChoiceZodSchema.array().parse(choices),
    };
};
exports.createCompletions = createCompletions;
